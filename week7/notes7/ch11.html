<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Further Functions Notes</title>
    <link rel="stylesheet" href="../../week1/style1.css" />
</head>
<body style="text-align: left;">
    <h1>Chapter 11 Notes</h1>
    <p>In JavaScript, functions are first-class objects, which means they can be passed around in the same way as every other value.</p>
    <h3>Function Properties and Methods</h3>
    <ul>
        <li>all functions have a <span class="code">length</span> property that returns the number of parameters the function has</li>
        <li>Call and Apply Methods
            <ul><span class="code">call()</span> method can be used to set the value of <span class="code">this</span> inside a function to an object</ul>
            <ul>If the function that’s called requires any parameters, these need to be provided as arguments after the first argument, 
                which is always the value of <span class="code">this</span>.</ul>
                <ul>If a function doesn’t refer to an object as this in its body, it can still be called using the call() method, but you need to 
                    provide null as its first argument. For example, we could call the square() function using the call() method, like so:<br>
                    <span class="code">square.call(null, 4)<br>
                    << 16</span></ul>
                <ul><span class="code">apply()</span> method works in the same way, except the arguments of the function are provided as an array, even if there is only one argument</ul>
        </li>
        <li>Custom Properties
            <ul>Memoization
                <ul>useful feature of this is that it provides result caching</ul>
                <ul>If a function takes some time to compute a return value, we can save the result in a <span class="code">cache</span> property. </ul>
            </ul>
        </li>
        
    </ul>
    <h3>Immediately Invoked Function Expressions</h3>
    <ul>
        <li style="color:yellow">IIFE – (pronounced 'iffy')</li>
        <li>anonymous function that is invoked as soon as it is defined</li>
        <li>The function also has to be made into an expression, which is done by placing the whole declaration inside parentheses</li>
        <li>Good for keeping any variables wrapped up within the scope of the function and the global namespace is not polluted with lots of variable names.</li>
        <li>Temporary Variables
            <ul>Placing any code that uses the temporary variable inside an IIFE will ensure it’s only available while the IIFE is invoked, then it will disappear</ul>
        </li>
        <li>Initialization Code
            <ul>IIFE can be used to set up any initialization code that there’ll be no need for again</ul>
            <ul>IIFE will be invoked once, and can set up any variables, objects and event handlers when the page loads</ul>
            <ul>much of this can be achieved in ES6 by simply placing the code inside a block</ul>
            <ul>variables have block scope when <span class="code">const</span> or <span class="code">let</span> are used</ul>
        </li>
        <li>Safe Use of Strict Mode
            <ul>One of the problems with simply placing <span class="code">'use strict'</span> at the beginning of a file is that it will enforce 
                strict mode on all the JavaScript in the file</ul>
            <ul>the recommended way to use strict mode is to place all your code inside an IIFE, like so:<br>
                <span class="code">&emsp;(function() { 
                    <br>&emsp;&emsp;'use strict';
                    <br>&emsp;&emsp;// All your code would go inside this function 
                    <br>&emsp;})();</span></ul>
            
        </li>
    </ul>
    <h3>Functions that Define and Rewrite Themselves</h3>
    <ul>
        <li>JavaScript means that a function is able to not only call itself, but <span style="color:yellow">define itself</span>, 
            and <span style="color:yellow">even redefine itself</span></li>
        <li>assign an anonymous function to a variable that has the same name as the function.</li>
        <li>Init-Time Branching
            <ul>functions that rewrite themselves, known as init-time branching</ul>
            <ul>Once the function has been invoked, it’s <u>rewritten based on the browser’s capabilities</u></ul>
        </li>
    </ul>
    <h3>Recursive Functions</h3>
    <ul>
        <li>function that invokes itself until a certain condition is met</li>
        <li>useful when iterative processes are involved</li>
        <li>Collatz Conjecture
            <ul>If the number is even, divide it by two</ul>
            <ul>If the number is odd, multiply it by three and add one
                <ul>For example, if we start with the number 18, we would have the following sequence:</ul>
                <ul>18, 9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, ...</ul></ul>
        </li>
    </ul>
    <h3>Callbacks</h3>
    <ul>
        <li>functions passed to other functions as arguments and then invoked inside the function they are passed to</li>
        <li>Event-driven Asynchronous Programming
            <ul>used to facilitate event-driven asynchronous programming</ul>
            <ul>non-blocking techniques can be used to ensure that the program continues to run</ul>
            <ul>callback can be created that’s invoked when the event happens - so the code can run out of order, or <b>asynchronously</b></ul>
            <ul>By using callbacks, we ensure that waiting for task such as <span class="code">click</span>, <span class="code">keyPress</span>,
                completion of a file download, data returned from a database, or the result of a complex operation
                to complete doesn't hold up the execution of other parts of the program</ul>
                <ul><span style="color:red">Remember: </span>If an event only takes a small amount of time to happen, the program will still have to wait 
                    until other parts of the program have executed before the callback is invoked.</ul>
                <ul>a callback always has to wait for the current execution stack to complete before it’s invoked</ul>  
        </li>
        <li>Callback [Heck]
            <ul style="color:yellow">The more callbacks that are used can result in messy and confusing'spaghetti code'</ul>
            <ul>Callback hell is the term used to refer to this tangled mess of code</ul>
        </li>
        <li> Promises
            <ul>A <b>promise</b> represents the future result of an asynchronous operation</ul>
            <ul>don't do anything that can't already be achieved using callbacks, but they help simplify the process, and avoid the convoluted code</ul>
            <ul>The Promise Life Cycle
                <ul>When a promise is created, it calls an asynchronous operation and is then said to be pending</ul>
                <ul>Once the operation has completed, the promise is said to have been settled, which can have two outcomes:
                    <ul><span style="color:yellow">Resolved</span> ― the asynchronous operation was completed successfully.</ul>
                    <ul><span style="color:yellow">Rejected</span> ― the asynchronous operation didn’t work as expected, wasn't successfully completed or resulted in an error.</ul>
                </ul>
            </ul>
            <ul>Creating A Promise
                <ul>created using a constructor function</ul>
                <ul>takes a function called an <span style="color:yellow">executor</span> as an argument</ul>
                <ul>executor initializes the promise and starts the asynchronous operation</ul>
                <ul>also accepts two functions as arguments: the <span class="code">resolve()</span> function is called if the operation is successful, 
                    and the <span class="code">reject()</span> function is called if the operation fails. The general layout of a promise can be seen 
                    in the code below:<br>
                    <span class="code">const promise = new Promise( (resolve, reject) => { <br>
                        &emsp;// initialization code goes here<br>
                        &emsp;if (success) {<br>
                            &emsp; &emsp;resolve(value);<br>
                            &emsp;} else {<br>
                                &emsp; &emsp;reject(error);<br>
                                &emsp;}<br>
                    });</span></ul>
            </ul>
            <ul>Dealing With A Settled Promise
                <ul>Once a promise has been settled, the <span class="code">then()</span> method can be used to deal with the outcome</ul>
                <ul>accepts two arguments:
                    <ul>first is a fulfilment function that’s called when the promise is resolved. Any data returned from the resolve() function 
                        will be passed along to this function</ul>
                    <ul>second argument is a rejection function that’s called if the promise is rejected. Similar to the fulfilment function, 
                        the rejection function receives any data returned from the reject() function</ul>
                </ul>
            </ul>
            <ul>Chaining Multiple Promises
                <ul>If each function that performs an asynchronous operation returns a promise, we can chain the then() methods 
                    together to form a sequential piece of code that’s easy to read</ul>
                <ul>Each promise will only begin once the previous promise has been settled.</ul>
            </ul>
            <ul>Async Functions
                <ul>These functions are preceded by the async keyword and allow you to write asynchronous code as if it was synchronous</ul>
                <ul>achieved by using the await operator before an asynchronous function.</ul>
            </ul>
            <ul>Generalized Functions
                <ul>instead of having lots of specific functions, one function can be written that accepts a callback.</ul>
            </ul>
            <ul>Functions That Return Functions
                <ul>We've just seen that functions can accept another function as an argument (a callback), but they can also return a function.</ul>
            </ul>
        </li>
    </ul>
    <h3>Closures</h3>
    <ul>
        <li>Function Scope
            <ul>the value of a variable was only available inside the block it was created inside if the <span class="code">const</span> or 
                <span class="code">let</span> keywords were used. This also applies to the body of a function if the 
                <span class="code">var</span> keyword is used.</ul>
                <ul style="color:yellow"><b>A closure is a reference to a variable that was created inside the scope of another function, 
                    but is then kept alive and used in another part of the program.</b></ul>
                    <ul>an 'inner' function, which is declared inside another function, has full access to all of the variables 
                        declared inside the scope of the function in which it’s declared (the 'outer' function)</ul>
        </li>
        <li>Returning Functioins
            <ul>closure is formed <u>when the inner function is returned by the outer function</u>, maintaining access to any 
                variables declared inside the enclosing function</ul>
            <ul>closure doesn't just have access to the value of a variable, it can also change the value of the variable 
                long after the function in which it was originally declared has been invoked</ul>
        </li>
        <li>A Practical example
            <ul>closure is formed when a function returns another function that then maintains access to any variables 
                created in the original function’s scope</ul>
        </li>
        <li>A Counter Example
            <ul>Closures not only have access to variables declared in a parent function's scope, they can also change the value of these variables</ul>
        </li>
        <li>Generators
            <ul>These are special functions used to produce iterators that maintain the state of a value</ul>
            <ul>To define a generator function, an asterisk symbol (*) is placed after the function declaration, like so: <br>
                <span class="code">
                function* exampleGenerator() {<br>
                    &emsp;// code for the generator goes here<br>
                }</span></ul>
                <ul>Calling a generator function doesn’t actually run any of the code in the function; it returns a Generator 
                    object that can be used to create an iterator that implements a next() method that returns a value every 
                    time the next() method is called</ul>
                <ul>Generator functions employ the special <span class="code">yield</span> keyword that is used to return a value. </ul>
                <ul>The difference between the <span class="code">yield</span> and the <span class="code">return</span> keywords is that 
                    by using <span class="code">yield</span>, the state of the value returned is remembered the next time <span class="code">yield</span> 
                    is called</ul>
                <ul>It’s also possible to iterate over the generator to invoke it multiple times</ul>
        </li>
    </ul>
    <h3>Functional Programming</h3>
    <ul>
        <li>JavaScript has always supported functional-style programming due to functions being first-class objects.</li>
        <li>fundamental elements of functional programming that JavaScript excels at: the ability to pass functions as arguments, 
            return them from other functions, and use anonymous functions and closures </li>
            <li>Functional programming is a programming paradigm.</li>
            <li>Other examples of programming paradigms include object oriented programming and procedural programming</li>
        <li>Pure Functions
            <ul>A pure function is a function that adheres to the following rules:
                <ol>1) <span style="color:yellow">The return value of a pure function should only depend on the values provided as arguments.</span> 
                    It doesn't rely on values from somewhere else in the program.</ol>
                <ol>2) <span style="color:yellow">There are no side-effects.</span> A pure function doesn't change any values or data elsewhere in the program. 
                    It only makes non-destructive data transformations and returns new values, rather than altering any of the underlying data.</ol>
                <ol>3) <span style="color:yellow">Referential transparency.</span> Given the same arguments, a pure function will always return the same result.</ol>
            </ul>
            <ul>In order to follow these rules, any pure function must have:
                <ul>At least one argument; otherwise the return value must depend on something other than the arguments of the function, 
                    breaking the first rule</ul>
                <ul>A return value; otherwise there’s no point in the function (unless it has changed something else in the program – 
                    in which case, it’s broken the 'no side-effects' rule).</ul>
            </ul>
            <ul>Pure functions help to make functional programming code more concise and predictable than in other programming styles</ul>
            <ul>Referential transparency makes pure functions easy to test as they can be relied on to return the same values when the same arguments are provided</ul>
            <ul>any return values can be cached</ul>
            <ul><span style="color:rgb(255, 42, 227)">One point to note</span> is that using <span class="code">const</span> to declare variables will help to 
                avoid destructive data transformations</ul>
            <ul>Functional programming uses pure functions as the building blocks of a program</ul>
            <ul>a program becomes a sequence of expressions based on the return values of pure functions</ul>
            <ul>emphasis is placed on using <span style="color:yellow">function composition</span> to combine pure functions together to complete more complex tasks</ul>
            <ul>By only performing a single task, pure functions are more flexible
                <ul>They are not tightly coupled and they are more modular, as each function can be improved upon or replaced without interfering with any of the other functions</ul>
            </ul>
        </li>
        <li>Higher-Order Functions
            <ul>functions that accept another function as an argument, or return another function as a result, or both.</ul>
            <ul>Closures are used extensively in higher-order functions as they allow us to create a generic function that can 
                be used to then return more specific functions based on its arguments.</ul>
            <ul>creating a closure around a function's arguments that keeps them 'alive' in a return function</ul>
            <ul><span style="color:yellow">core tenets of functional programming: </span>
                it allows generic higher-order functions to be used to return more specific functions based on particular parameters</ul>
        </li>
        <li>Currying
            <ul>a process that involves the partial application of functions</ul>
            <ul>named after the logician Haskell Curry — not the spicy food</ul>
            <ul>A function is said to be curried when not all arguments have been supplied to the function, so it returns 
                another function that retains the arguments already provided, and expects the remaining arguments that were 
                omitted when the original function was called</ul>
                <ul>final result is only returned once all the expected arguments have eventually been provided</ul>
                <ul>relies on higher-order functions that are able to return partially applied functions</ul>
                <ul>All curried functions are higher-order functions because they return a function, but not all higher-order 
                    functions are curried</ul>
                <ul>The <span class="code">power()</span> function above is an example of a higher-order function that can be curried 
                    as it will expects two arguments, but will return another, curried function, if the only one argument is provided</ul>
                <ul>allows you to turn a single function into a series of functions instead</ul>
                <ul>A General Curry Function
                    <ul>It’s possible to use a curry() function to take any function and allow it to be partially applied</ul>
                    <ul>The curry function is the following:
                        <span class="code"><br>function curry(func,...oldArgs) { <br>
                            &emsp;return function(...newArgs) { <br>
                                &emsp;&emsp;const allArgs = [...oldArgs,...newArgs];<br>
                                &emsp;&emsp;return func(...allArgs);<br>
                                &emsp;}<br>
                        }</span>
                    </ul>
                    <ul>This function accepts a function as its first argument, which is stored as <span class="code">func</span>. 
                        The rest operator is used to collect all the other arguments together as <span class="code">...oldArgs</span>. 
                        These are the arguments of the function that is the first argument. It then returns a function that accepts 
                        some new arguments that are stored in the variable <span class="code">...newArgs</span>. These are then 
                        lumped together with <span class="code">...oldArgs</span> to make <span class="code">...newArgs</span> 
                        using the spread operator. The return value of this function is obtained by invoking the original function, 
                        which is accessed using a closure over <span class="code">func</span> and passed the combined 
                        arguments <span class="code">...allArgs</span></ul>
                </ul>
        </li>
    </ul>
    <h3>Getting Functional</h3>
    <ul>
        <li>Advocates of functional programming can be quite partisan about its benefits</li>
        <li>even adopting some of its principles, such as keeping functions as pure as possible, 
            and keeping changes in state to a minimum, will help improve the standard of your programming</li>
    </ul>
    <h3>Chapter Summary</h3>
    <ul>
        <li>Functions have built-in properties such as length, but can have custom properties added.</li>
        <li>All functions have call() and apply() methods that can invoke a function with the value of this bound to an object that is provided as an argument.</li>
        <li>Immediately Invoked Function Expressions or IIFEs are functions that are enclosed in parentheses and immediately followed by double parentheses so they’re invoked. They are useful for namespacing variables and setting default values.</li>
        <li>Functions are able to dynamically redefine themselves in the body of the function, depending on certain conditions.</li>
        <li>A recursive function will keep invoking itself until a certain condition is met.</li>
        <li>A callback is a function that’s provided as an argument to another function.</li>
        <li>Callbacks are frequently used in asynchronous programming as part of the event loop. This means that a program can continue to run in a single thread while waiting for another task to be completed.</li>
        <li>Promises can be used instead of callbacks to deal with multiple asynchronous actions in sequence. They also provide a nicer mechanism for handling errors.</li>
        <li>Functions that return other functions are known as higher-order functions.</li>
        <li>A closure is the process of keeping a reference to a variable available outside the scope of the function it was originally defined in.</li>
        <li> A generator is created by placing an asterisk character (*) after the function keyword.</li>
        <li>A generator function will return an iterator object that provides a next() method, which returns the next value in a sequence that is defined in the generator function.</li>
        <li>Functional programming involves breaking processes down into steps that can be applied as a series of functions.</li>
        <li>Pure functions are functions that don't rely on the state of the code they are called from, have no side-effects, and always give the same result when given the same arguments (referential transparency).</li>
        <li>Currying or partial application is the process of applying one argument at a time to a function. A new function is returned until all the arguments have been used.</li></ul>
        
    Examples can be found <a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/11/k01nwuzs">here.</a>
    <a href="../../index.html">Home</a>
</body>
</html>